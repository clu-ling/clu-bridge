<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>clu.bridge.conversion API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>clu.bridge.conversion</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations
from clu.bridge import processors
from clu.bridge import odinson
from clu.bridge.typing import Tokens, Indices

from enum import Enum
from typing import Dict, List, Literal, Optional, Set, Text, Tuple, Type
import abc


__all__ = [&#34;ConversionUtils&#34;]
class ConversionUtils:
  &#34;&#34;&#34;Conversion utilities for greater CLU family docs&#34;&#34;&#34;
  
  @staticmethod
  def to_odinson(doc: processors.Document) -&gt; odinson.Document:
    pass

  @staticmethod
  def to_odinson_sentence(s: processors.Sentence) -&gt; odinson.Sentence:
    pass

  @staticmethod
  def to_processors(doc: odinson.Document) -&gt; processors.Document:
    return processors.Document(
      id = doc.id,
      sentences = [ConversionUtils.to_processors_sentence(s) for s in doc.sentences]
    )

  @staticmethod
  def create_character_offsets(toks: Tokens) -&gt; Tuple[Indices, Indices]:
    &#34;&#34;&#34;Create start and end char offsets for tokens by treating them as whitespace-delimited&#34;&#34;&#34;
    current_start = -1
    current_end = 0
    start_offsets = []
    end_offsets = []
    for tok in toks:
      current_start += 1
      start_offsets.append(current_start)
      current_start += len(tok)
      current_end += len(tok)
      end_offsets.append(current_end)
      current_end += 1
    return start_offsets, end_offsets


  @staticmethod
  def to_processors_sentence(s: odinson.Sentence) -&gt; processors.Sentence:

    graphs: Optional[processors.GraphMap] = None
    # NOTE: by convention, these are non-plural
    fields_dict: Dict[Text, Optional[Tokens]] = {
      &#34;raw&#34; : None,
      &#34;word&#34; : None,
      &#34;tag&#34; : None,
      &#34;lemma&#34; : None,
      &#34;entity&#34; : None,
      &#34;chunk&#34; : None,
      &#34;norm&#34; : None
    }

    def is_token_field(field: odinson.Field, name: Optional[odinson.Fields] = None) -&gt; bool:
      _is_token_field = isinstance(field, odinson.TokensField)
      if name is not None:
        return True if _is_token_field and field.name == name else False
      return _is_token_field
    

    for field in s.fields:
      if is_token_field(field) and field.name in fields_dict:
        fields_dict[field.name] = field.tokens
      elif isinstance(field, odinson.GraphField):
        # assume graph is hybrid
        graphs = graphs or dict()
        graphs[processors.Graphs.HYBRID_DEPENDENCIES] = processors.DirectedGraph(
          edges = [processors.Edge(source=e[0], destination=e[1], relation=e[2]) for e in field.edges],
          roots = list(field.roots)
        )

    PLACEHOLDER = [&#34;&#34;] * s.numTokens
    raw = fields_dict.get(&#34;raw&#34;, PLACEHOLDER) or fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER
    start_offsets, end_offsets = ConversionUtils.create_character_offsets(raw)
    return processors.Sentence(
      raw = raw,
      startOffsets = start_offsets,
      endOffsets = end_offsets,
      words = fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER,
      tags = fields_dict.get(&#34;tag&#34;, None),
      lemmas = fields_dict.get(&#34;lemma&#34;, None),
      entities = fields_dict.get(&#34;entity&#34;, None),
      chunks= fields_dict.get(&#34;chunk&#34;, None),
      norms = fields_dict.get(&#34;norm&#34;, None),
      graphs = graphs
    )


#   /** Start character offsets for the raw tokens; start at 0 */
#   val startOffsets: Array[Int],
#   /** End character offsets for the raw tokens; start at 0 */
#   val endOffsets: Array[Int],
# exclude_none=True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="clu.bridge.conversion.ConversionUtils"><code class="flex name class">
<span>class <span class="ident">ConversionUtils</span></span>
</code></dt>
<dd>
<div class="desc"><p>Conversion utilities for greater CLU family docs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConversionUtils:
  &#34;&#34;&#34;Conversion utilities for greater CLU family docs&#34;&#34;&#34;
  
  @staticmethod
  def to_odinson(doc: processors.Document) -&gt; odinson.Document:
    pass

  @staticmethod
  def to_odinson_sentence(s: processors.Sentence) -&gt; odinson.Sentence:
    pass

  @staticmethod
  def to_processors(doc: odinson.Document) -&gt; processors.Document:
    return processors.Document(
      id = doc.id,
      sentences = [ConversionUtils.to_processors_sentence(s) for s in doc.sentences]
    )

  @staticmethod
  def create_character_offsets(toks: Tokens) -&gt; Tuple[Indices, Indices]:
    &#34;&#34;&#34;Create start and end char offsets for tokens by treating them as whitespace-delimited&#34;&#34;&#34;
    current_start = -1
    current_end = 0
    start_offsets = []
    end_offsets = []
    for tok in toks:
      current_start += 1
      start_offsets.append(current_start)
      current_start += len(tok)
      current_end += len(tok)
      end_offsets.append(current_end)
      current_end += 1
    return start_offsets, end_offsets


  @staticmethod
  def to_processors_sentence(s: odinson.Sentence) -&gt; processors.Sentence:

    graphs: Optional[processors.GraphMap] = None
    # NOTE: by convention, these are non-plural
    fields_dict: Dict[Text, Optional[Tokens]] = {
      &#34;raw&#34; : None,
      &#34;word&#34; : None,
      &#34;tag&#34; : None,
      &#34;lemma&#34; : None,
      &#34;entity&#34; : None,
      &#34;chunk&#34; : None,
      &#34;norm&#34; : None
    }

    def is_token_field(field: odinson.Field, name: Optional[odinson.Fields] = None) -&gt; bool:
      _is_token_field = isinstance(field, odinson.TokensField)
      if name is not None:
        return True if _is_token_field and field.name == name else False
      return _is_token_field
    

    for field in s.fields:
      if is_token_field(field) and field.name in fields_dict:
        fields_dict[field.name] = field.tokens
      elif isinstance(field, odinson.GraphField):
        # assume graph is hybrid
        graphs = graphs or dict()
        graphs[processors.Graphs.HYBRID_DEPENDENCIES] = processors.DirectedGraph(
          edges = [processors.Edge(source=e[0], destination=e[1], relation=e[2]) for e in field.edges],
          roots = list(field.roots)
        )

    PLACEHOLDER = [&#34;&#34;] * s.numTokens
    raw = fields_dict.get(&#34;raw&#34;, PLACEHOLDER) or fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER
    start_offsets, end_offsets = ConversionUtils.create_character_offsets(raw)
    return processors.Sentence(
      raw = raw,
      startOffsets = start_offsets,
      endOffsets = end_offsets,
      words = fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER,
      tags = fields_dict.get(&#34;tag&#34;, None),
      lemmas = fields_dict.get(&#34;lemma&#34;, None),
      entities = fields_dict.get(&#34;entity&#34;, None),
      chunks= fields_dict.get(&#34;chunk&#34;, None),
      norms = fields_dict.get(&#34;norm&#34;, None),
      graphs = graphs
    )</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="clu.bridge.conversion.ConversionUtils.create_character_offsets"><code class="name flex">
<span>def <span class="ident">create_character_offsets</span></span>(<span>toks: Tokens) ‑> Tuple[List[int], List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Create start and end char offsets for tokens by treating them as whitespace-delimited</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_character_offsets(toks: Tokens) -&gt; Tuple[Indices, Indices]:
  &#34;&#34;&#34;Create start and end char offsets for tokens by treating them as whitespace-delimited&#34;&#34;&#34;
  current_start = -1
  current_end = 0
  start_offsets = []
  end_offsets = []
  for tok in toks:
    current_start += 1
    start_offsets.append(current_start)
    current_start += len(tok)
    current_end += len(tok)
    end_offsets.append(current_end)
    current_end += 1
  return start_offsets, end_offsets</code></pre>
</details>
</dd>
<dt id="clu.bridge.conversion.ConversionUtils.to_odinson"><code class="name flex">
<span>def <span class="ident">to_odinson</span></span>(<span>doc: processors.Document) ‑> <a title="clu.bridge.odinson.Document" href="odinson.html#clu.bridge.odinson.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_odinson(doc: processors.Document) -&gt; odinson.Document:
  pass</code></pre>
</details>
</dd>
<dt id="clu.bridge.conversion.ConversionUtils.to_odinson_sentence"><code class="name flex">
<span>def <span class="ident">to_odinson_sentence</span></span>(<span>s: processors.Sentence) ‑> clu.bridge.odinson.Sentence</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_odinson_sentence(s: processors.Sentence) -&gt; odinson.Sentence:
  pass</code></pre>
</details>
</dd>
<dt id="clu.bridge.conversion.ConversionUtils.to_processors"><code class="name flex">
<span>def <span class="ident">to_processors</span></span>(<span>doc: odinson.Document) ‑> <a title="clu.bridge.processors.Document" href="processors.html#clu.bridge.processors.Document">Document</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_processors(doc: odinson.Document) -&gt; processors.Document:
  return processors.Document(
    id = doc.id,
    sentences = [ConversionUtils.to_processors_sentence(s) for s in doc.sentences]
  )</code></pre>
</details>
</dd>
<dt id="clu.bridge.conversion.ConversionUtils.to_processors_sentence"><code class="name flex">
<span>def <span class="ident">to_processors_sentence</span></span>(<span>s: odinson.Sentence) ‑> <a title="clu.bridge.processors.Sentence" href="processors.html#clu.bridge.processors.Sentence">Sentence</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_processors_sentence(s: odinson.Sentence) -&gt; processors.Sentence:

  graphs: Optional[processors.GraphMap] = None
  # NOTE: by convention, these are non-plural
  fields_dict: Dict[Text, Optional[Tokens]] = {
    &#34;raw&#34; : None,
    &#34;word&#34; : None,
    &#34;tag&#34; : None,
    &#34;lemma&#34; : None,
    &#34;entity&#34; : None,
    &#34;chunk&#34; : None,
    &#34;norm&#34; : None
  }

  def is_token_field(field: odinson.Field, name: Optional[odinson.Fields] = None) -&gt; bool:
    _is_token_field = isinstance(field, odinson.TokensField)
    if name is not None:
      return True if _is_token_field and field.name == name else False
    return _is_token_field
  

  for field in s.fields:
    if is_token_field(field) and field.name in fields_dict:
      fields_dict[field.name] = field.tokens
    elif isinstance(field, odinson.GraphField):
      # assume graph is hybrid
      graphs = graphs or dict()
      graphs[processors.Graphs.HYBRID_DEPENDENCIES] = processors.DirectedGraph(
        edges = [processors.Edge(source=e[0], destination=e[1], relation=e[2]) for e in field.edges],
        roots = list(field.roots)
      )

  PLACEHOLDER = [&#34;&#34;] * s.numTokens
  raw = fields_dict.get(&#34;raw&#34;, PLACEHOLDER) or fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER
  start_offsets, end_offsets = ConversionUtils.create_character_offsets(raw)
  return processors.Sentence(
    raw = raw,
    startOffsets = start_offsets,
    endOffsets = end_offsets,
    words = fields_dict.get(&#34;word&#34;, PLACEHOLDER) or PLACEHOLDER,
    tags = fields_dict.get(&#34;tag&#34;, None),
    lemmas = fields_dict.get(&#34;lemma&#34;, None),
    entities = fields_dict.get(&#34;entity&#34;, None),
    chunks= fields_dict.get(&#34;chunk&#34;, None),
    norms = fields_dict.get(&#34;norm&#34;, None),
    graphs = graphs
  )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="clu.bridge" href="index.html">clu.bridge</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="clu.bridge.conversion.ConversionUtils" href="#clu.bridge.conversion.ConversionUtils">ConversionUtils</a></code></h4>
<ul class="">
<li><code><a title="clu.bridge.conversion.ConversionUtils.create_character_offsets" href="#clu.bridge.conversion.ConversionUtils.create_character_offsets">create_character_offsets</a></code></li>
<li><code><a title="clu.bridge.conversion.ConversionUtils.to_odinson" href="#clu.bridge.conversion.ConversionUtils.to_odinson">to_odinson</a></code></li>
<li><code><a title="clu.bridge.conversion.ConversionUtils.to_odinson_sentence" href="#clu.bridge.conversion.ConversionUtils.to_odinson_sentence">to_odinson_sentence</a></code></li>
<li><code><a title="clu.bridge.conversion.ConversionUtils.to_processors" href="#clu.bridge.conversion.ConversionUtils.to_processors">to_processors</a></code></li>
<li><code><a title="clu.bridge.conversion.ConversionUtils.to_processors_sentence" href="#clu.bridge.conversion.ConversionUtils.to_processors_sentence">to_processors_sentence</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>